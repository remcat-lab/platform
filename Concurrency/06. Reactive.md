## Reactive

- 대부분의 웹 기반 서비스들은 클라이언트가 요청을 하면 서버가 응답해주는 pull 방식으로 구현되어 있고 역사적으로 오래되었다. 이런 pull 방식의 비효율성이나, 실시간 반응을 위해 Socket을 유지하면서 처리하는 방식이 추가 되었고, push 방식을 적용하려고 한다.
- 그렇다면 pull과 push의 서버 자원 효율성을 생각해보고 적용해야 한다.

# 📊 비교: Push vs Pull (클라이언트 500명 기준, 10초 간격 처리)

[ Push 방식: SignalR ]
- 서버가 변경 발생 시 500명의 클라이언트에게 브로드캐스트
- 데이터 전송 횟수 = 변경 횟수 × 클라이언트 수
  예: 1분에 100건 변경 → 100 × 500 = 50,000건 메시지 전송
- 네트워크는 효율적일 수 있으나, **서버는 연결 500개 유지 + 상태 추적 필요**
- 클라이언트가 필터링해야 하므로 낭비 발생 가능

[ Pull 방식: 주기적 폴링 ]
- 클라이언트가 10초마다 한 번씩 서버에 요청
  예: 500명 × 6회/분 = 3,000 req/min
- 요청마다 서버가 쿼리 수행 → 데이터 없을 수도 있음
- 서버는 연결 유지 부담 없음 (Stateless)
- 클라이언트가 조건 기반으로 데이터를 받아감 → 불필요한 데이터 없음


| 항목           | **Push (SignalR)**             | **Pull (주기적 요청)**       |
| ------------ | ------------------------------ | ----------------------- |
| **서버 동작**    | 변경 발생 시 클라이언트로 직접 전송           | 클라이언트가 주기적으로 요청         |
| **네트워크 트래픽** | 변경이 없으면 전송 없음 (이상적 구조)         | 주기마다 요청/응답 왕복           |
| **지연 시간**    | 실시간에 가깝고 매우 짧음                 | 주기 간격만큼 늦어짐 (최대 10초 등)  |
| **서버 부하**    | 클라이언트 수 × 메시지 처리 수             | 클라이언트 수 × 주기적 요청 처리     |
| **클라이언트 제어** | 수신 시점 제어 불가 (필터링은 가능)          | 요청 시점과 조건 제어 가능         |
| **유지비용**     | 연결 상태 유지, 상태 추적 필요             | Stateless, 단순함          |
| **스케일 아웃**   | SignalR Scale-out (Redis 등) 필요 | 수평 확장 용이 (로드밸런서만으로도 가능) |

──────────────────────────────────────────────
🧠 선택 기준

[Push가 유리한 경우]
- 변경 건수가 적고, 클라이언트 수가 많을 때
- 실시간 반응성이 중요할 때 (예: 알림, 채팅, 알람)
- 데이터 전송량이 작고, 공통 정보일 때

[Pull이 유리한 경우]
- 변경이 빈번하거나 데이터가 큼
- 클라이언트마다 관심 조건이 다를 때
- 서버 연결 유지 비용이 부담될 때


🧠 클라이언트 측면에서 Pull vs Push 적용 기준

[📥 Pull 방식 - 클라이언트 주도]
- 사용자가 요청할 때만 데이터 가져옴 (예: 버튼 클릭, 주기적 polling)
- 상태 동기화 부담 적음
- 리소스 소비 예측 가능 (주기적 타이머 기반 등)
- 데이터가 크거나, 사용자가 직접 제어해야 할 때 유리

💡 사용 예:
- 대시보드: "새로고침" 버튼
- 조건 검색 결과
- 유휴 상태일 때 정기 sync

🛠 자주 쓰는 Rx 기법:
- Debounce: 검색어 입력, 슬라이더 조작 등
- Retry / Timeout: 네트워크 불안정 대응
- Delay / Interval: polling 간격 조절
- Sample: 일정 간격으로만 처리 (예: CPU 1초 단위 모니터링)

[📤 Push 방식 - 서버 주도]
- SignalR/WebSocket으로 실시간 이벤트 수신
- 즉시 반응해야 하는 경우 유리
- 상태 유지 필요 (실시간 연결, 동기화 로직)
- 수신 후 데이터 fetch 여부는 클라이언트가 결정 가능

💡 사용 예:
- 알람/경고 팝업
- 실시간 채팅, 실시간 주식 시세
- 다중 사용자 협업 (공동 편집 등)

🛠 자주 쓰는 Rx 기법:
- Buffer: 일정 시간 내 이벤트 묶음 처리
- Throttle: 과도한 이벤트 수신 억제
- DistinctUntilChanged: 같은 이벤트 반복 무시
- ObserveOn: UI 스레드 바인딩 보장 (Dispatcher로 전환)

──────────────────────────────────────────────
📌 Pull vs Push 클라이언트 전략 요약

1. 📥 Pull
   - 데이터가 커서 조건 기반으로 요청해야 할 때
   - 사용자가 직접 트리거 (조회, 버튼 등)
   - 실시간성이 불필요하거나 과도한 이벤트가 문제될 때

2. 📤 Push
   - 이벤트 수신이 즉시 사용자에게 보여져야 할 때
   - 상태 변화 알림, 실시간 피드
   - 서버 이벤트를 기준으로 클라이언트 상태 업데이트 필요할 때

3. 🧪 Hybrid + Rx
   - Push는 알림만 받고, 실제 데이터는 Pull로 가져오기
   - Rx로 이벤트 제어 (throttle, distinct, observeOn 등)
