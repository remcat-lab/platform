[동시성 애플리케이션에서 불변 컬렉션 & 동시성 컬렉션 비교]

1. 불변 컬렉션 (Immutable Collections)

───────────────────────────────────────────────────────────

공통 특징:
- 생성 이후 내부 데이터가 절대 변경되지 않음.
- 데이터 변경 시 새로운 컬렉션 인스턴스를 반환.
- 다중 스레드에서 락 없이 안전하게 공유 가능.
- 변경 작업이 잦을 경우 성능 저하와 GC 부하 발생.

ImmutableList<T>
- 순서를 유지하는 불변 리스트.
- 인덱스로 빠른 접근 가능.
- 변경 시 내부적으로 구조 공유(Structural Sharing)를 사용해 메모리 낭비 최소화.
- 예: 읽기 전용 메뉴 목록, 버전별 설정 값 저장.

ImmutableHashSet<T>
- 중복 없는 불변 집합.
- 해시 기반이므로 검색 속도가 빠름.
- 변경 시 기존 데이터는 재사용, 변경분만 새로 구성.
- 예: 접근 권한 목록, 고정된 키 집합.

ImmutableDictionary<TKey, TValue>
- 키-값 쌍의 불변 매핑.
- 읽기 전용 매핑 테이블, 설정 정보, 고정된 라우팅 정보 등에 적합.
- 키 검색 속도 빠르고 스레드 안전.
- 예: 코드-메시지 매핑, 환경 설정 테이블.


───────────────────────────────────────────────────────────

2. 동시성 컬렉션 (Concurrent/Producer-Consumer Collections)

───────────────────────────────────────────────────────────

공통 특징:
- 내부 구조는 가변(Mutable)이며 동시성 제어를 통해 안전성 확보.
- 생산자–소비자 패턴, 메시지 전달, 비동기 파이프라인 등에 사용.

Channel<T>
- System.Threading.Channels 제공.
- Lock-free 설계로 고성능.
- Bounded/Unbounded 지원, capacity 초과 시 await로 백프레셔 제공.
- 비동기 지원 (ReadAsync/WriteAsync).
- 예: 로그 스트리밍, 실시간 데이터 처리.

BlockingCollection<T>
- System.Collections.Concurrent 기반 동기형 컬렉션.
- 내부에서 ConcurrentQueue/Stack 등 사용 + SemaphoreSlim으로 동기 제어.
- Bounded/Unbounded 지원, capacity 초과 시 블로킹.
- 비동기 미지원(별도 Task.Run 필요).
- 예: 간단한 멀티스레드 큐, 레거시 코드 호환.

BufferBlock<T> (TPL Dataflow)
- 메시지 전달과 데이터 흐름 제어에 특화.
- 블록 간 링크(LinkTo)로 파이프라인 구성 가능.
- 비동기 지원(Post/ReceiveAsync).
- 내부적으로 TaskCompletionSource와 락 사용.
- 예: ETL 파이프라인, 데이터 처리 DAG.

AsyncProducerConsumerQueue<T>
- 단순한 await 기반 비동기 생산자–소비자 큐.
- 커스텀 구현 또는 오픈소스 라이브러리에서 제공.
- 락 사용 기반이며 기능 단순.
- 예: 경량 비동기 작업 큐.

AsyncCollection<T>
- BlockingCollection 스타일을 비동기로 구현.
- await 기반 Add/Take 제공.
- 락 기반 동시성 제어.
- 예: 비동기 데이터 수집 및 처리 큐.


───────────────────────────────────────────────────────────

3. 비교 표

| 항목                  | 불변성 여부 | 비동기 지원 | 락 사용 여부     | 주 사용 시나리오                                      |
|-----------------------|-------------|-------------|------------------|-------------------------------------------------------|
| ImmutableList<T>      | ✔️          | N/A         | 필요 없음        | 순서 있는 읽기 전용 데이터 공유                       |
| ImmutableHashSet<T>   | ✔️          | N/A         | 필요 없음        | 집합 형태 읽기 전용 데이터 공유                       |
| ImmutableDictionary<K,V>| ✔️        | N/A         | 필요 없음        | 읽기 전용 키-값 매핑 공유                             |
| Channel<T>            | ❌          | ✔️          | 최소화(원자연산) | 고성능 파이프라인, 동시성 스트림                      |
| BlockingCollection<T> | ❌          | ❌          | 락 사용          | 레거시 동기 생산자–소비자                             |
| BufferBlock<T>        | ❌          | ✔️          | 락+Task 기반     | 메시지 기반 파이프라인                                |
| AsyncProducerConsumerQueue<T>| ❌   | ✔️          | 락 사용          | 단순 비동기 큐                                        |
| AsyncCollection<T>    | ❌          | ✔️          | 락 사용          | 비동기 BlockingCollection 스타일                      |


───────────────────────────────────────────────────────────

4. 요약
- 불변 컬렉션:
  * 읽기 전용 데이터 공유에 이상적.
  * 변경이 드물고 읽기가 많은 환경에서 효율적.
- 동시성 컬렉션:
  * 상태 변경과 데이터 전달이 빈번한 경우에 적합.
  * 생산자–소비자, 파이프라인 처리, 메시지 큐에 활용.
- 실무 패턴:
  * 읽기 전용 스냅샷: 불변 컬렉션 사용.
  * 실시간 데이터 흐름: 동시성 컬렉션 사용.
