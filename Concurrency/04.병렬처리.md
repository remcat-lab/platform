# TPL(Task Parallel Library)
 - 병렬처리를 처리하는 과정을 단순화 해, 생산성을 높이기 위한 라이브러리.
 - 각 반복에서 적은양의 작업만 수행하거나, 반복이 많지 않을 경우, 병렬화 오버헤드로 인해 코드가 더 느릴 수 있다.
 
## 데이터 병렬 처리
 - 컬렉션의 각 데이터를 대상으로 같은 작업을 할때 사용된다.
 - for, foreach 구문을 사용하는 것 처럼 Parallel.For, Foreach를 사용해 처리할 수 있다.
 - 취소는 CancellationToken을 이용해 비동기의 취소 처럼 처리할 수 있고(실행 자체의 취소)
 - 중지는 state.stop을 이용하며, 이미 시작된 것 이외에 추가적인 루프의 시작을 막는 방법이다.(반복을 중단)

 | **특징**       | **`CancellationToken`**                                    | **`ParallelLoopState.Stop()`** |
| ------------ | ---------------------------------------------------------- | ------------------------------ |
| **목적**       | 작업을 **취소**하고 더 이상 진행되지 않도록 함                               | 병렬 반복문을 더 이상 **실행하지 않도록 중지**   |
| **사용 방식**    | `CancellationToken.IsCancellationRequested`를 사용하여 취소 요청 확인 | `state.Stop()`을 호출하여 반복문을 중지   |
| **중지 방식**    | 작업 자체를 **취소**하고, 안전하게 예외 처리를 통해 종료                         | 이미 실행된 작업은 종료되지만, 이후 반복문만 중지   |
| **예외 처리**    | `OperationCanceledException`을 사용할 수 있음                     | 예외를 발생시키지 않음                   |
| **주요 사용 사례** | 비동기 작업 취소, 대규모 작업 중 취소가 필요할 때                              | 병렬 반복문 중단, 불필요한 반복 중지 필요 시     |

- CPU 바운드를 포함한 비동기 병렬 방식과 Parallel을 이용한 방식의 차이
- 결국 스케줄러의 작업 방식의 차이로 성능이 차이난다고 보면 된다.(조금씩 늘려 갈것인가, 한번에 CPU Core에 맞춰 최대로 갈것인가의 차이)

| **특징**        | **비동기 병렬 처리 (Async / Await)**                                                                                        | **Parallel을 이용한 병렬 처리**                                                                                      |
| ------------- | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **작업 유형**     | 비동기 작업 (주로 I/O 바운드, 일부 CPU 바운드)                                                                                      | CPU 바운드 작업 (주로 반복문)                                                                                          |
| **스레드 관리**    | 스레드를 직접 관리하지 않음. **Thread Pool**을 사용하여 스레드를 관리. I/O 바운드 작업 시 스레드를 자유롭게 풀에 반환, CPU 바운드 작업 시 스레드를 사용.                  | **Thread Pool**을 사용하여 고정된 수의 스레드가 여러 작업을 동시에 실행. 각 작업은 별도의 스레드에서 실행되며, 작업 수에 따라 스레드가 동적으로 관리됨.               |
| **작업 대기 방식**  | `async/await` 키워드를 통해 **비동기적으로 작업 대기**. 작업이 완료되면 결과를 받아옴. I/O 작업 중에 CPU는 다른 작업을 할 수 있음.                              | `Parallel.For` 또는 `Parallel.ForEach`에서 반복문을 병렬로 실행. 각 반복 작업이 완료될 때까지 대기하지 않고 병렬로 실행.                         |
| **작업 스케줄링**   | 비동기 함수는 **I/O 바운드** 작업에 적합하며, 대기 중인 작업을 다른 스레드로 교체하여 **CPU 효율성**을 극대화. CPU 바운드 작업도 비동기적으로 처리할 수 있으나, 실제로 스레드를 많이 사용. | `Parallel`은 **CPU 바운드** 작업에 적합. 작업이 CPU에서 병렬로 실행되므로 스레드 풀에 의해 스케줄되고 스레드를 직접적으로 사용하는 방식.                      |
| **스레드 사용**    | I/O 작업에서는 **스레드를 사용하지 않음**. CPU 바운드 작업에서는 스레드가 사용되며, CPU 리소스를 다룰 때 스레드를 차지.                                          | 병렬 처리시 스레드 풀에서 **동적으로 스레드를 사용**. CPU 코어 수와 비슷한 수준의 스레드를 사용할 수 있지만, 많은 스레드를 생성하면 성능이 저하될 수 있음.                |
| **상태 관리**     | **스레드가 비차단 방식**으로 작업을 대기하면서, I/O 바운드 작업에서 스레드가 회수되고, CPU 리소스를 적게 사용. `await`는 I/O 작업 후 CPU가 대기 중인 상태로 다른 작업을 처리.     | 병렬 작업이 끝날 때까지 **모든 작업이 블로킹**됨. 스레드가 각 작업을 병렬로 실행하며, 작업이 완료될 때까지 기다려야 함.                                      |
| **성능 최적화**    | **비동기 처리**는 I/O 작업에서 성능 최적화에 매우 효과적이며, I/O 대기 중 CPU가 다른 작업을 할 수 있도록 하여 **리소스 효율성**이 높음.                              | CPU 바운드 작업에 대해 효율적이며, 특히 CPU 리소스를 여러 스레드로 나누어 병렬 처리함. 단, 너무 많은 스레드를 생성하면 성능이 **떨어질 수 있음**.                   |
| **적합한 작업 유형** | **I/O 바운드 작업** (네트워크 호출, 파일 시스템 작업 등)과 **부분적으로 CPU 바운드 작업**에 적합.                                                     | **CPU 바운드 작업** (데이터 처리, 복잡한 계산 등)에 적합.                                                                       |
| **예외 처리**     | 비동기 작업에서는 **`try/catch`** 문을 통해 예외를 처리하고, 비동기 메서드가 예외를 던지면 `await`에서 이를 잡을 수 있음.                                     | `Parallel.For`/`Parallel.ForEach`는 여러 스레드에서 예외를 발생시킬 수 있으며, 예외가 발생하면 `AggregateException`을 통해 모든 예외를 모아 처리함. |
| **작업 종료 방식**  | 작업이 완료되거나 `CancellationToken`을 통해 취소될 때까지 기다림. 취소는 비동기적으로 이루어짐.                                                      | `ParallelLoopState.Stop()`을 통해 반복을 중지하거나 `CancellationToken`을 사용하여 병렬 반복을 취소할 수 있음.                          |


## 병렬 집계
 - Parallel.Foreach의 localfinally와  PLINQ의 Aggregate는 거의 동일한 시기에 개발되었으며 성능 차이는 없고, 스타일의 차이라고 보면 된다.

| 특징    | `Parallel.ForEach`                                                 | PLINQ                                |
| ----- | ------------------------------------------------------------------ | ------------------------------------ |
| 스타일   | 명령형                                                                | 선언형                                  |
| 코드    | `Parallel.ForEach(source, options, localInit, body, localFinally)` | `source.AsParallel().Aggregate(...)` |
| 로컬 상태 | `localInit`, `localFinally` 를 통해 각 스레드별 상태 관리                      | `Aggregate` 로 병렬적으로 reduce 가능        |
| 유연성   | 비동기/세밀한 루프 제어                                                      | 쿼리식/조합 쉬움                            |
| 오류 처리 | `AggregateException` 발생                                            | `AggregateException` 발생              |
| 작업 단위 | 루프                                                                 | 컬렉션/쿼리                               |


## 병렬 호출
 - 컬렉션이 아닌 메서드 단위로 나누어진 것을 병렬 처리하기 위해 사용한다.
 - 아래의 Task.WhenAll + Task.Run으로 동작하는 것을 Parallel.Invoke로 쉽게 만들어 주는 도구라고 보면 된다.

``` csharp
await Task.WhenAll(
    Task.Run(() => DoTask1()),
    Task.Run(() => DoTask2())
);
```

``` csharp
Parallel.Invoke(
    () => DoTask1(),
    () => DoTask2(),
    () => DoTask3()
);
```
 - Parallel.Foreach, PLINQ, Parallel.Invoke를 비교하면 아래와 같다

| 특징  | `Parallel.ForEach` | `PLINQ`   | `Parallel.Invoke` |
| --- | ------------------ | --------- | ----------------- |
| 패턴  | 루프                 | LINQ 쿼리   | 여러 메서드            |
| 대상  | 컬렉션 요소 반복          | 컬렉션 요소 쿼리 | 서로 다른 작업          |
| 스타일 | 명령형                | 선언형       | 명령형               |
| 반환  | 완료될 때까지            | 완료될 때까지   | 완료될 때까지           |

 
## 동적 병렬 처리
 - 병렬화할 데이터가 미리 결정되지 않고, 더 많은 병렬 작업을 만들어내야 하는 상황에서 사용하는 방식
 - 작업의 개수가 실행하면서 동적으로 결정이 되는 경우에 사용된다. (이진 트리 같은 경우 찾기 전에 얼마나 더 해야 하는지 모른다)
 - AttachToParent는 부모 작업이 동적으로 자식 작업을 만들어 실행하고 난 뒤, 자식이 끝날때 까지 기다린다고 생각하면 된다.
 - Task의 두가지 용도 비교

| 구분            | **비동기 처리 (Asynchronous)**                                                                                       | **병렬 처리 (Parallel)**                                                                                                                 |
| ------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| **목적**        | I/O 바운드 대기 시간 동안 다른 작업을 진행하기 위해                                                                                 | CPU 코어를 최대한 활용해 작업을 빠르게 끝내기 위해                                                                                                       |
| **스레드 점유**    | 점유하지 않음 (비차단)                                                                                                   | 점유함 (차단 가능)                                                                                                                          |
| **대표 메서드/패턴** | ✅ `await` <br> ✅ `Task.WhenAll` <br> ✅ `Task.WhenAny` <br> ✅ `WithCancellation` <br> 🟡 `ContinueWith` (비동기 가능) | 🔴 `.Wait()` <br> 🔴 `.Result` <br> 🔴 `Task.WaitAll` <br> 🔴 `Task.WaitAny` <br> 🔴 `.Wait(timeout)` <br> 🟡 `ContinueWith` (동기 가능) |
| **여러 작업 처리**  | `Task.WhenAll` (비차단, 모두 완료될 때까지) <br> `Task.WhenAny` (비차단, 하나만 끝나면)                                             | `Task.WaitAll` (차단, 모두 끝날 때까지) <br> `Task.WaitAny` (차단, 하나만 끝날 때까지)                                                                  |
| **예시 코드**     | `csharp await Task.Delay(1000); `<br>`await Task.WhenAll(tasks);`                                               | `csharp tasks[0].Wait(); `<br>`Task.WaitAll(tasks);`                                                                                 |
| **상태 확인**     | `IsCompleted`, `IsFaulted` <br> (상태 확인 후 await 가능)                                                              | `IsCompleted`, `IsFaulted` <br> (상태 확인 후 Wait 가능)                                                                                    |
| **권장 대상 작업**  | I/O 바운드 (파일, 네트워크, DB)                                                                                          | CPU 바운드 (연산, 시뮬레이션, 이미지 처리)                                                                                                          |
| **코드 스타일**    | 선언적, 가독성 높음 (`async/await`)                                                                                     | 명령적, 즉시 완료 기다림                                                                                                                       |


## PLINQ
 - PLINQ vs Parallel

| 구분         | **PLINQ (`AsParallel()`)**                                 | **Parallel (`Parallel.For/ForEach`)**                            |
| ---------- | ---------------------------------------------------------- | ---------------------------------------------------------------- |
| **패러다임**   | 선언형(Declarative)                                           | 명령형(Imperative)                                                  |
| **코드 스타일** | LINQ 쿼리 문법과 자연스럽게 결합<br>예: `.Select().Where().Aggregate()` | 명시적인 루프/메서드 작성                                                   |
| **적합한 작업** | 데이터 집합에 대한 변환/필터링/집계                                       | 데이터 집합 또는 특정 범위에 대한 독립적인 반복 작업                                   |
| **가독성**    | 높음<br>(LINQ 스타일로 깔끔)                                       | 낮을 수 있음<br>(루프 안에 복잡한 로직 작성될 경우)                                 |
| **제어 가능성** | 낮음<br>작업 단위, 취소, 상태 등을 세밀하게 제어하기 어렵다                       | 높음<br>`localInit`, `localFinally`, `ParallelLoopState` 등으로 제어 가능 |
| **데이터 흐름** | 파이프라인 처리<br>중간 단계에서 연속 처리 가능                               | 각 작업은 독립적, 별도 파이프라인 없음                                           |
| **병렬성 조절** | `.WithDegreeOfParallelism()` 으로 가능                         | `ParallelOptions.MaxDegreeOfParallelism`                         |
| **예외 처리**  | `AggregateException`                                       | `AggregateException`                                             |
| **상태 공유**  | 어렵다<br>(데이터 플로우 위주라 상태를 만들기 까다로움)                          | 용이하다<br>(`localInit`/`localFinally` 등으로 각 스레드별 상태 관리)            |
| **성능**     | 대체로 유사<br>하지만 쿼리 최적화에 강점                                   | 대체로 유사<br>루프/알고리즘 최적화에 강점                                        |
| **사용 예시**  | 배열에서 짝수의 합 구하기, 그룹별 집계, 대규모 데이터 변환                         | 파일 1000개를 각자 처리, 수치 계산, 이미지 프로세싱                                 |


