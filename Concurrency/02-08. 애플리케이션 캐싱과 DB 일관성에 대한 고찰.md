
# 📒 애플리케이션 캐싱과 DB 일관성에 대한 고찰

## 🧭 전제: 왜 애플리케이션에서 캐싱을 하는가?

- DB는 자체적으로 버퍼풀/캐시를 운영하여 디스크 I/O를 줄임.
- 하지만 DB까지의 **네트워크 왕복 비용**과 **쿼리 실행 비용**은 여전히 발생.
- 애플리케이션 캐시는:
  - DB를 아예 호출하지 않음.
  - 더 빠르고, 더 많은 요청을 처리 가능.
  - DB 부하를 줄여줌.

---

## 🎯 문제: 캐시된 값이 DB에서 바뀌면?

- DB가 데이터의 **진실(Source of Truth)** 임.
- 캐시는 언제나 최신일 수 없고, 낡아질 수 있음.
- 동적 캐싱(`GetOrAdd`)을 쓴다고 해서 DB에서 바뀐 것을 자동으로 알 수는 없음.

---

## 🧭 데이터 특성에 따른 선택

| 데이터 | 캐싱 적합성 | 이유 |
|---|---|---|
| 국가 목록, 코드 테이블 | 👍 적합 | 거의 변하지 않음 |
| 인기 게시글 | 👍 적합 | 조금 낡아도 괜찮음 |
| 실시간 주가, 센서 데이터 | 👎 부적합 | 항상 최신이어야 함 |
| 사용자 장바구니 | 👎 부적합 | 개인별, 즉각 반영 필요 |

---

## 🚀 캐시 최신성을 유지하는 전략

### 1️⃣ TTL (Time To Live)
- 캐시에 유효기간을 설정해 자동 만료.
- 간단하지만, 만료 전까지는 낡은 데이터일 수 있음.

```csharp
_cache.Set(key, value, TimeSpan.FromMinutes(5));
```

---

### 2️⃣ 명시적 무효화
- DB를 업데이트하는 코드에서 캐시도 같이 갱신/삭제.
- API에 `UpdateUser()`가 있다면 캐시에서도 `userId`를 지움.

```csharp
_cache.Remove(userId);
```

---

### 3️⃣ Pub/Sub 기반 무효화
- DB나 다른 서비스에서 데이터가 변경되면 메시지를 발행.
- 애플리케이션 캐시는 이를 구독해 무효화.
- 대규모 분산 환경에서 유용.

```
DB → Kafka Topic → Consumer → Cache Invalidate
```

---

### 4️⃣ 매번 DB에서 읽기
- 데이터가 너무 자주 바뀌거나 항상 최신이어야 한다면 캐시를 포기.
- 성능보다 정확성이 더 중요할 때 적합.

---

## 🧭 앱 시작 시 로딩 패턴 vs 동적 캐싱

| 패턴 | 장점 | 단점 |
|---|---|---|
| 앱 시작 시 로딩 | 코드 단순, 메모리 내에서 빠름 | 데이터량 크면 부담, 최신성 낮음 |
| 동적 캐싱 (`GetOrAdd`) | 메모리 효율적, 일부만 로딩 | 코드 복잡, 최신성 낮음 |

---

## 📊 결론

✅ 애플리케이션 캐싱은 성능과 부하 감소를 위한 것.  
✅ 캐싱을 쓸지 여부는 데이터의 특성에 따라 결정.  
✅ 최신성이 중요한 데이터는 TTL/무효화 전략을 같이 사용.  
✅ 동적 캐싱은 “조금 낡아도 괜찮다”는 전제가 필요.

---

> 💡 **캐싱은 정확성과 성능의 트레이드 오프이다.**  
> 먼저 데이터의 특성을 정의하고, 그에 맞는 캐싱 전략을 선택하자.
