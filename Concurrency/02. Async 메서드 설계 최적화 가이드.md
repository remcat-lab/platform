
# ✅ Async 메서드 설계 최적화 가이드

## 1. Async 시그니처의 의미와 목적

- Async 메서드는 **비동기 작업을 위한 시그니처 형태**입니다.
- 내부 작업이 실제로 비동기가 아닐 수도 있지만, 호출자 입장에서는 await 패턴을 강제합니다.

## 2. Async 시그니처 유지가 필요한 경우

- 일부 경로는 비동기(I/O), 일부는 동기 (e.g. 캐시 hit/miss)
- 인터페이스 설계 상 Task 반환이 필수인 경우
- API 일관성을 유지하기 위한 경우 (e.g. GetAsync, SaveAsync)
- UI, ASP.NET 같은 호출자가 await 패턴을 기대하는 경우

## 3. 동기 메서드가 가능한 경우

- 비동기 I/O 작업이 전혀 없음
- 호출 스택이 동기적으로 흘러도 문제가 없음
- API 일관성 요구가 없음

→ ✔️ **이 경우 무조건 동기 메서드가 더 빠르고, 더 단순하며, 더 안전하다.**

## 4. Task.FromResult와 ValueTask의 목적

| 도구             | 목적                                                   |
|------------------|--------------------------------------------------------|
| Task.FromResult  | 비동기 시그니처 유지 + 즉시 동기 반환 (하지만 힙 할당 발생) |
| ValueTask        | 비동기 시그니처 유지 + 동기 반환 최적화 (힙 할당 없음) |

## 5. 성능 비교

| 방법                   | 속도 (ns) | 힙 할당 | 코드 복잡도 |
|------------------------|------------|---------|--------------|
| 동기 메서드 (`T`)      | ~5-10 ns   | 없음    | 가장 낮음    |
| Task.FromResult        | ~50-60 ns  | 있음    | 낮음         |
| ValueTask              | ~20-30 ns  | 없음    | 높음         |

→ ✔️ 동기 메서드가 항상 가장 빠르고 단순

## 6. 최종 결론

- ✅ 동기로 충분하면 무조건 동기 메서드로
- ✅ Async 시그니처 유지가 필요한 이유가 명확할 때만 FromResult, ValueTask 사용
- ✅ ValueTask는 성능 최적화가 절대적으로 필요한 극단적 핫패스에서만 의미 있음
- ❌ 불필요한 Async 시그니처는 코드 복잡도와 성능 모두에 손해

## 7. 실전 설계 가이드

| 상황                                | 추천 방법                          |
|-------------------------------------|-------------------------------------|
| 비동기 I/O 포함                     | async/await + Task                 |
| 무조건 동기                         | 그냥 동기 메서드                   |
| 캐시 hit → 동기, miss → 비동기       | ValueTask 또는 Task + FromResult    |
| API 일관성 필요 (공개 API 등)        | Task                               |
| 내부 핫패스, 라이브러리, 커넥션 풀 등 | ValueTask                           |

## 8. 요약

> **"FromResult가 필요한지 한 번 더 의심하고, ValueTask가 필요한지 두 번 더 의심해라. 가능하다면 그냥 동기 메서드가 정답이다."**
