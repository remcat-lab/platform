### 🔁 백업 흐름 (클라이언트 중심)

1. **클라이언트**에서 백업 유틸리티 실행 (with `ProjectId`, `대상 폴더`)
2. **서버**에 `ProjectId`로 가장 최신 Commit 요청
3. **서버 응답**: Commit에 포함된 전체 파일 metadata (full path, mtime, size)
4. **클라이언트에서 현재 파일 시스템 상태와 비교**
   - 변경된 파일 (mtime/size 다름)
   - 추가된 파일 (경로 없음)
5. **변경/추가 파일들과 그 metadata**를 tar.gz로 압축
6. 서버에 전송
7. **서버는 metadata + hash 비교로 중복 제거 후 DB 저장**

---

## ✅ 이 구조의 장점

### 1. 🧠 **클라이언트가 더 많은 문맥을 알고 있음**
- 전체 파일 시스템을 직접 접근 가능 → `mtime`, `size`, `existence` 쉽게 확인
- 변경된 파일 여부를 **서버가 추론할 필요 없음** → 서버는 단순 수신처리만 하면 됨

### 2. 🚀 **성능 최적화가 쉬움 (Rust 활용)**
- 클라이언트는 멀티스레드로 파일 탐색, 메타데이터 추출, 해시 계산을 병렬 처리 가능
- Rust의 `rayon`, `walkdir`, `flate2` 등 사용 시 고속 처리

### 3. ⚙️ **구조가 단순해짐 (비즈니스 로직 분리)**
- 서버는 dumb storage 역할에 집중 (metadata 저장, 중복 제거, 응답)
- 복잡한 변경 감지/비교 로직은 클라이언트에 있음 → **역할 분리로 유지보수 쉬움**

### 4. 🧪 **테스트 및 디버깅 용이**
- 서버에 문제 생겼을 때 클라이언트가 보낸 것만 보면 됨 (tar.gz + metadata)
- 클라이언트는 테스트시 로컬에서 metadata diff만 해도 동작 확인 가능

### 5. 💡 **증분 백업 구현이 명확해짐**
- 클라이언트가 직전 상태를 명확히 알고 있으므로 어떤 파일이 변화했는지 정확히 판단 가능
- 서버는 수동 비교, 재요청, 커밋 상태 비교 등을 하지 않아도 됨

---

## 🧱 시스템 구조 비교

| 항목 | 서버 중심 방식 | 클라이언트 중심 방식 (제안한 방식) |
|------|----------------|----------------------------------|
| 변경 파일 판단 | 서버가 추론 | 클라이언트가 정확히 판단 |
| 전송 데이터 | 변경된지 모르는 전체 파일/시간 기반 추정 | 변경된 파일과 정확한 metadata |
| 서버 부담 | 비교 로직, 재요청 등 로직 복잡 | 수신 및 저장 중심 |
| 동기화 정확도 | mtime 누락 가능성 있음 | full metadata diff로 정확 |
| 확장성 | 서버 쪽 부하가 집중 | 클라이언트 분산 처리 |
| 코드 구조 | 로직 분산, 상태 관리 복잡 | 역할 명확히 분리됨 |
| 추후 기능 확장 | 어렵고 충돌 우려 | 유연한 버전 관리 및 기능 확장 용이 |

---

## 🔧 설계 팁

1. 클라이언트에서 metadata 추출 시:
   - full path, size, mtime 외에 선택적으로 `partial hash`를 추가해도 좋음
2. 서버 응답의 commit metadata는 gzip 등으로 압축해서 내려도 무방 (전송 최적화)
3. metadata는 정렬해서 보내면 서버에서도 중복 비교/기록이 더 간편
4. 서버에서는 동일 파일은 `hash`로 deduplication, 동일 metadata는 버전 관리 형태로 저장

---

## ✅ 결론

> 지금 제안한 구조는 **더 단순하고, 신뢰성 있고, 확장성 있는 백업 구조입니다.**

- 클라이언트가 상태 판단을 책임지고
- 서버는 수신과 저장에 집중하는 방식은
- 실제 백업 솔루션 (예: restic, borg, duplicity 등)에서도 사용하는 구조입니다.

---


``` mermaid
flowchart TD
    subgraph Client
        A1[백업 프로그램 시작<br/>ProjectId와 폴더 정보 서버로 전송]
        A2[서버로부터 최근 Commit의<br/>전체 파일 metadata 수신]
        A3[로컬 폴더 스캔하여 현재 metadata 추출]
        A4[서버 metadata와 비교하여<br/>변경 및 추가된 파일 목록 생성]
        A5[변경/추가 파일과 metadata를<br/>tar.gz로 압축]
        A6[tar.gz와 metadata를 서버에 전송]
    end

    subgraph Server
        B1[tar.gz 및 metadata 수신]
        B2[파일 해시 계산 및 중복 제거]
        B3[새로운 파일과 metadata DB에 저장]
        B4[Commit 정보 업데이트]
    end

    A1 --> A2 --> A3 --> A4 --> A5 --> A6 --> B1 --> B2 --> B3 --> B4


```
