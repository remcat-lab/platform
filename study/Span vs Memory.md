Memory<T>가 Span<T>보다 사용 제약이 적은 것은 사실이지만, 그럼에도 불구하고 Span<T>를 사용하는 이유는 성능과 가용 범위 때문입니다. 
모든 것을 Memory<T>로만 사용하지 않는 결정적인 이유는 다음과 같습니다.
1. 성능 (Performance)
Span<T>은 가장 빠릅니다. 
오버헤드 제로: Span<T>은 ref struct로 설계되어 스택에만 존재하며, CPU 레벨에서 포인터 연산만큼이나 빠르게 동작합니다.
Memory의 한계: Memory<T>는 실제 데이터에 접근할 때 내부적으로 .Span 속성을 호출하여 다시 Span으로 변환하는 과정을 거칩니다. 즉, Memory를 사용하더라도 결국 데이터를 읽고 쓸 때는 Span의 성능을 빌려 쓰는 셈입니다.
2. 다룰 수 있는 메모리의 종류가 다름
Span<T>은 Memory<T>보다 훨씬 더 넓은 범위의 메모리를 다룰 수 있습니다. 
Memory<T>: 주로 힙(Heap)에 할당된 배열이나 string만 다룰 수 있습니다.
Span<T>: 다음 세 가지를 모두 다룰 수 있는 유일한 타입입니다.
힙 메모리: 일반적인 배열
스택 메모리: stackalloc을 통해 할당된 메모리 (매우 빠름, GC 부하 없음)
네이티브 메모리: 관리되지 않는 외부 메모리 (C++ 라이브러리 연동 등) 
csharp
// Span은 stackalloc을 통해 GC가 관리하지 않는 스택 메모리를 직접 다룰 수 있습니다.
// Memory<T>는 이 작업을 수행할 수 없습니다.
Span<byte> stackBuffer = stackalloc byte[100]; 
코드를 사용할 때는 주의가 필요합니다.

3. 구조적 강제성 (Safety & Intent)
Span<T>은 "이 데이터는 지금 이 메서드 안에서만 즉시 처리하고 끝낸다"는 의도를 명확히 합니다.
만약 모든 곳에 Memory<T>를 사용하면, 데이터가 언제 어디서 수정될지 추적하기 어려워질 수 있습니다.
Span<T>은 스택 전용이므로 비동기 호출이나 다른 스레드에 실수로 넘기는 것을 컴파일 레벨에서 차단하여, 메모리 안전성을 높여줍니다. 
4. 이미 만들어진 수많은 .NET API들
.NET 라이브러리의 수많은 저수준 메서드(int.Parse, string.Concat 등)는 이미 ReadOnlySpan<char>를 인자로 받도록 설계되어 있습니다. 최신 .NET 환경에서 성능 이점을 얻으려면 결국 Span을 써야만 합니다.
요약: 언제 무엇을 쓸까?
상황 	추천 타입	이유
일반적인 로직, 반복문, 파싱	Span<T>	가장 빠르고 메모리 할당이 없음
스택 메모리(stackalloc) 사용	Span<T>	Memory<T>는 지원 불가
비동기 메서드(async/await) 사용	Memory<T>	Span<T>은 비동기 경계를 넘을 수 없음
클래스의 필드로 저장할 때	Memory<T>	Span<T>은 힙에 저장될 수 없음
결론적으로, Memory<T>는 Span<T>을 담기 위한 "저장소(Storage)" 역할을 하고, Span<T>은 데이터를 다루기 위한 "도구(Worker)" 역할을 한다고 보시면 됩니다.
성능이 중요한 작업이라면 Span<T> 가이드라인을 참고하여, 가능한 한 Span을 기본으로 사용하고 비동기나 저장 기능이 필요할 때만 Memory로 확장하는 것이 .NET 권장 패턴입니다.
