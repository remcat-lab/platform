ArrayPool<T>(특히 ArrayPool<byte>.Shared)를 사용하는 것이 단순히 new byte[]로 할당하는 것보다 권장되는 핵심 이유는 가비지 컬렉션(GC)의 오버헤드를 줄여 애플리케이션의 전체 성능을 향상시키기 때문입니다.
주요 이유는 다음과 같습니다.
1. 가비지 컬렉터(GC) 부하 감소
새로운 배열을 할당(new byte[])하면 사용 후 GC가 이를 회수해야 합니다. 반면 ArrayPool은 배열을 메모리에 유지하며 재사용하므로, GC가 관리해야 할 객체 수가 줄어듭니다. 이는 특히 빈번한 할당이 일어나는 상황에서 GC 일시 정지(Stop-the-world) 현상을 방지하는 데 효과적입니다.
2. LOH(Large Object Heap) 파편화 방지
.NET에서 85,000바이트 이상의 큰 배열은 LOH에 할당됩니다. LOH는 일반 힙과 달리 메모리 압축(Compaction)이 자주 발생하지 않아 파편화가 생기기 쉽습니다. ArrayPool을 통해 큰 배열을 재사용하면 LOH 메모리 부족(Out of Memory) 예외를 예방할 수 있습니다. Microsoft Learn의 ArrayPool 안내에서 관련 상세 내용을 확인할 수 있습니다.
3. 할당 비용 절감
메모리를 새로 할당하는 작업 자체가 CPU 자원을 소모합니다. 이미 생성된 배열을 풀에서 빌려오는(Rent) 방식은 새로운 메모리 영역을 찾아 초기화하는 과정보다 훨씬 빠릅니다.
💡 사용 시 주의사항 (Best Practices)
반납 필수: 사용이 끝난 배열은 반드시 ArrayPool<T>.Return()을 호출하여 풀에 돌려주어야 합니다. 돌려주지 않으면 메모리 누수와 동일한 효과가 발생합니다.
배열 크기: Rent(minSize)는 요청한 크기보다 더 큰 배열을 반환할 수 있습니다. 따라서 반드시 반환된 배열의 전체 길이가 아닌, 실제 사용한 데이터의 길이를 별도로 관리해야 합니다.
데이터 초기화: Return() 시 clearArray: true 옵션을 주지 않으면 이전 사용자가 남긴 데이터가 남아있을 수 있어 보안상 주의가 필요합니다.
실무적인 구현 방법은 .NET 기술 블로그의 ArrayPool 활용 사례 등을 참고하면 도움이 됩니다.
