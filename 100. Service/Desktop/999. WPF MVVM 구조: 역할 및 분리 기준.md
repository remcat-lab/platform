# WPF MVVM 구조: 역할 및 분리 기준

| 계층 / 컴포넌트 | 역할 | 분리 기준 / 주요 내용 |
|----------------|-------|-------------------|
| **View (XAML)** | UI의 시각적 구성 요소를 정의. 사용자 인터페이스 레이아웃, 스타일, 바인딩 대상 지정 | - UI에 직접적인 비즈니스 로직이나 상태 저장 코드를 포함하지 않음<br>- ViewModel의 바인딩 프로퍼티에 데이터 바인딩만 수행<br>- 가능한 순수하게 선언적 UI 구성에 집중 |
| **Code Behind (View.xaml.cs)** | UI 관련 이벤트 핸들링, 순수 UI 제어 (예: 마우스 클릭, 애니메이션 제어 등) | - UI 제어에만 집중하며, 비즈니스 로직이나 상태 변경 호출을 직접 포함하지 않음<br>- ViewModel 또는 State의 메서드를 호출하는 중개자 역할 가능<br>- Command 바인딩 미사용 시 UI 이벤트 처리 위치 |
| **ViewModel** | UI 바인딩용 프로퍼티(ObservableProperty) 제공, UI에 필요한 데이터 포맷, State와의 인터페이스 역할 수행 | - UI에 필요한 최소한의 데이터(읽기/쓰기 가능)를 노출<br>- State의 이벤트를 구독하여 자신의 프로퍼티 변경<br>- UI 이벤트 처리 시 State의 메서드를 호출하는 중개자 역할 수행<br>- API 호출은 하지 않는 것이 이상적 (단, 필요 시 호출 가능)<br>- State를 외부에 public 노출은 피하고, 인터페이스 또는 메서드로 접근 권장 |
| **State** | 애플리케이션의 핵심 상태와 비즈니스 로직을 보유, 상태 변경 시 이벤트로 알림 | - 순수 상태 저장소 역할 (DTO와는 다름)<br>- 서버 통신(API 호출)과 데이터 가공 책임<br>- 여러 ViewModel에서 공유 가능하도록 설계<br>- 상태 변경 시 이벤트를 통해 ViewModel에 알림<br>- UI 바인딩 직접 담당하지 않음 |
| **Model (DTO)** | API 요청 및 응답, DB 엔티티 등 데이터 전달용 클래스 | - 단순 데이터 구조체, 순수한 데이터 보관용<br>- 비즈니스 로직 없음<br>- State나 ViewModel에서 데이터 변환용으로 사용 |

---

# 역할과 분리 기준 요약

- **View**: UI 표현과 바인딩 대상 정의에 집중  
- **Code Behind**: UI 이벤트 처리 및 직접 UI 제어(단, 비즈니스 로직 제외)  
- **ViewModel**: UI와 State 사이 중재자, 바인딩 속성만 유지  
- **State**: 상태 저장과 비즈니스 로직, API 호출 및 결과 처리  
- **Model (DTO)**: 데이터 이동용 클래스, 순수 데이터 보관  

---

# 예시 흐름 (페이지 초기화 시)

1. **ViewModel**에서 API 호출을 직접 하거나, 또는 ViewModel이 State에 API 호출 요청  
2. **State**에서 API 호출 후 결과(Result DTO)를 받아 상태 갱신  
3. 상태 갱신 이벤트 발생 → **ViewModel**이 구독하여 UI 바인딩 프로퍼티 변경  
4. 바인딩된 **View**는 UI 자동 갱신  
5. UI 이벤트 발생 시 → **Code Behind**에서 이벤트 핸들링 → 필요한 경우 **ViewModel** 메서드 호출 → **ViewModel**은 다시 **State** 메서드 호출

---
